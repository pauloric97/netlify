var localWindow = window.inDapIF ? parent.window : window;

;(function(win) {

    'use strict';

    function ready(fn) {
        if (document.readyState != 'loading'){
            fn();
        } else {
            document.addEventListener('DOMContentLoaded', fn);
        }
    }

    win.utils = win.utils || {};
    win.utils.ready = ready;

})(localWindow);

/*******************************
 * Animations for floated notifications
 * authors: cnamor, adrianescat
*******************************/

/**
 * IIFE Module
 * @module
 * @param window-object
 * @param document-object
**/

;(function(win, doc, exports, meli) {

    'use strict';

    /**
     * LoyaltyProgressBars contructor
     * @constructor
     * @param {object} options
    **/
    function FloatedAnimations (options) {
        this.el = [];
        this.options = {
            'extraTimeForProgress': 500,
            'timeForTheLastOne': 2300,
            'baseTime': 2000
        };
        this.ui = {
            'notifications': [],
            'notificationsQuantity': [],
            'notificationContainer': []
        };
        // this.init();
        return this;
    }

    /**
     * Get the notifications elements
     * @function
    **/
    FloatedAnimations.prototype.setNotificationsElements = function() {
        this.ui.notifications = doc.querySelectorAll('.floating-notification-container');
        this.ui.notificationsQuantity = this.ui.notifications.length;
        this.ui.notificationContainer = doc.querySelector('.float-container');
        this.ui.bellButton = localWindow.document.getElementById('notiLink');

        if (this.ui.bellButton) {
            this.ui.bellButton.addEventListener('click', this.hideNotificationsContainer);
        }

        return this;
    };

    /**
     * Save the notifications elements
     * @function
     * @param notifications - nodeList
     * @param container (notification's container) - element
    **/
    FloatedAnimations.prototype.saveNotificationsElements = function(notifications, container) {
        this.ui.notifications = notifications;
        this.ui.notificationsQuantity = notifications.length;
        this.ui.notificationContainer = container;

        return this;
    };

    /**
     * Toggle visible the notification's container
     * @function
    **/
    FloatedAnimations.prototype.toggleNotificationContainer = function() {
        this.ui.notificationContainer.classList.toggle('visible');
        return this;
    };

    /**
     * Hide all notifications
     * @function
    **/
    FloatedAnimations.prototype.hideNotifications = function() {
        for (var i = 0; i < this.ui.notificationsQuantity; i++) {
            this.ui.notifications[i].classList.add('hidden-notification');
        }
        return this;
    };

    /**
     * Hide all notifications when the bell button is pressed
     * @function
    **/

    FloatedAnimations.prototype.hideNotificationsContainer = function() {
        doc.querySelector('.float-container').classList.remove('visible');
    };

    /**
     * Show a notification
     * @function
     * @param notification - nodeElement
    **/
    FloatedAnimations.prototype.showNotification = function(notification, notificationIndex, notificationsList, hideOthers) {

         hideOthers = hideOthers || true;
         var that = this;
        if (hideOthers) {
            this.hideNotifications();
        }

        if (notification) {

            if(win.melidata){
                //Cada notificaci?n individual que se muestra (melidata)
                win.melidata("cleanAndSend", "event", {
                    path:"/loyalty/notification",
                    data: {event_type: "shown"}
                });
            }

            notification.classList.remove('hidden-notification');
            if (notificationsList.data[notificationIndex].type == 'earn_points' && notificationsList.data[notificationIndex].level < 6) {
                var notificationData = notificationsList.data[notificationIndex];

                var options = {
                    'element': notification,
                    'initialPercentage': notificationData.initial_percentage,
                    'finalPercentage': notificationData.final_percentage,
                    'initialPoints': notificationData.initial_points,
                    'finalPoints': notificationData.final_points,
                    'speed': 2000
                }
                win.setTimeout(function() {
                    meli.progressAnimations.animateNotification(options);
                }, that.options.extraTimeForProgress);
            }

        } else {
            this.toggleNotificationContainer();
        }

        return this;
    };

    /**
     * Delay a notification
     * @function
     * @param notification - nodeElement
     * @param duration - integer
    **/
    FloatedAnimations.prototype.delayNotification = function(notification, duration, notificationIndex, notificationsList, acumulatedTime) {

        var that = this,
            extraTime = 0;
        if (!!notification){

            win.setTimeout(function() {
                that.showNotification(notification, notificationIndex, notificationsList);
            }, duration);

            //If its the last one
            if ((notificationIndex + 1) == that.ui.notificationsQuantity) {
                //its the first one too
                if (duration === 0) {
                    duration = that.options.baseTime;
                }

                win.setTimeout(function() {
                    that.hideNotificationsContainer();
                }, duration + that.options.timeForTheLastOne + acumulatedTime);
            }

            if (notificationsList.data[notificationIndex].type == 'earn_points') {
                extraTime += that.options.extraTimeForProgress;
            }
        }
        return extraTime;
    };

    /**
     * Animate notifications
     * @function
     * @param start - integer
     * @param notificationDuration - integer
    **/
    FloatedAnimations.prototype.animateNotifications = function(start, notificationDuration, notificationsList) {
        var that = this,
            acumulatedTime = 0;

        if (that.ui.notificationsQuantity > 0) {

            if (win.melidata){
                //Inicio de secuencia de mostrar (melidata)
                win.melidata("cleanAndSend", "event", {
                    path:"/loyalty/notification",
                    data: {event_type: "received"}
                });
            }

            win.setTimeout(function() {
                that.toggleNotificationContainer();
            }, start);

            for (var i = 0; i <= that.ui.notificationsQuantity; i++) {
                acumulatedTime += that.delayNotification(that.ui.notifications[i], (i * notificationDuration) + acumulatedTime, i, notificationsList, acumulatedTime);
            }
        }

        return that;
    };

    /**
     * FloatedAnimations export
    **/
    exports.notificationsAnimations = new FloatedAnimations();

}(localWindow, parent.window.document, localWindow.Meli.prototype, localWindow.meli));

/*******************************
 * Animations for progress bars and points/percentage counters
 * authors: cnamor
*******************************/

;(function(win, doc, exports, meli) {
    'use strict';

    function ProgressAnimations (options) {
        this.el = {};
        this.options = {
            'circumference': Math.PI * 2 * 45,
            'radius': 45,
            'halfPi': Math.PI * 0.5
        };
        this.ui = {};
        return this;
    }

    ProgressAnimations.prototype.animateBar = function(percentageCounter, options) {
        var that = this,
        /*
            percentageCounter comes as a percentage. We have to calculate
            the actual value of that circumference's percentage
        */
            value = percentageCounter * this.options.circumference * 0.01;

        that.ui.progressBar.setAttribute('stroke-dasharray', (value) + ', ' + (that.options.circumference));
    }

    ProgressAnimations.prototype.printPoints = function(container, value, roundDown) {
        // if points are smaller than percentage we have to round down. See pointProgression.
        container.innerText = Math.round(value) + ' ptos';
    }

    ProgressAnimations.prototype.printPercentage = function(container, value) {
        container.innerHTML = value + '<span>%</span>';
    }

    ProgressAnimations.prototype.animateText = function(pointCounter, percentageCounter, pointProgression, roundDown) {
        this.printPercentage(this.ui.percentageContainer, percentageCounter, roundDown);
        this.printPoints(this.ui.pointsContainer, pointCounter, this.options.finalPoints < this.options.finalPercentage);
    }

    ProgressAnimations.prototype.calculateDuration = function(initialPercentage, finalPercentage, speed) {
        return ((finalPercentage - initialPercentage) * speed) / this.options.circumference;
    }

    ProgressAnimations.prototype.setProgressBar = function(element) {
        this.ui.progressBar = element.querySelector('.progress');
        this.ui.pointsContainer = element.querySelector('.points');
        this.ui.percentageContainer = element.querySelector('.user-percent');

        return this;
    }

    ProgressAnimations.prototype.animateNotification = function(options) {

        // console.log(options); // los puntos y porcentajes
        // console.log(this.options); // radius, circunferencia, etc
        // console.log(this.ui); // containers de puntos y porcentajes

        this.setProgressBar(options.element);

        var that = this,
            preferredDuration = this.calculateDuration(options.initialPercentage, options.finalPercentage, options.speed),
            intervalDuration = preferredDuration / (options.finalPercentage - options.initialPercentage),
            pointCounter = options.initialPoints,
            pointRoundown =  options.finalPoints < options.finalPercentage,
            percentageCounter = options.initialPercentage;

            if (options.initialPercentage == options.finalPercentage) {
                var animationLoop = setInterval(function() {
                    that.printPoints(that.ui.pointsContainer, pointCounter, pointRoundown);
                    pointCounter += 1;

                    if (pointCounter > options.finalPoints) clearInterval(animationLoop);
                }, intervalDuration);
            } else {
                var pointProgression = (options.finalPoints - options.initialPoints) / (options.finalPercentage - options.initialPercentage);

                var animationLoop = setInterval(function() {
                    that.animateText(pointCounter, percentageCounter, pointProgression, true);
                    that.animateBar(percentageCounter, options);

                    percentageCounter++;
                    pointCounter += pointProgression;

                    if (percentageCounter > options.finalPercentage) clearInterval(animationLoop);
                }, intervalDuration);
            }

        return this;
    }

    /**
     * ProgressAnimations export
    **/
    exports.progressAnimations = new ProgressAnimations();

})(localWindow, parent.window.document, localWindow.Meli.prototype, localWindow.meli);

;(function(win, doc, exports, meli) {

    'use strict';
    var noop = function noop() {};

    var jsonpCount = 0;

    FloatNotifications.prototype.init = function(cfg) {
        var self = this;

        this.settings = {
            url : cfg.url || this.settings.url,
            debug : cfg.debug || this.settings.debug
        };

        meli.on('notifications:float', function() {
            self.recheck();
        });

        this.createHtml();

        this.showFloatNotifications();

        return this;
    };

    FloatNotifications.prototype.recheck = function() {

        doc.getElementById('float-container-list').innerHTML = "";

        this.showFloatNotifications();
    };

    FloatNotifications.prototype.bindEvents = function() {
        var notifications = doc.querySelectorAll('.floating-notification-container'),
            notificationsCount = notifications.length;


        for (var i = 0; i < notificationsCount; i++) {
            notifications[i].addEventListener('click', function (e) {
                if(win.melidata){
                    //Cada notificaci?n individual que se muestra (melidata)
                    win.melidata("cleanAndSend", "event", {
                        path:"/loyalty/notification",
                        data: {event_type: "open"}
                    });
                }
            });
        }

    };

    FloatNotifications.prototype.createHtml = function() {
        var floatContainer = doc.createElement('DIV');
        var floatCenteredContainer = doc.createElement('DIV');
        var notificationList = doc.createElement('UL');
        var notificationsBell = doc.querySelector('#notiLink');

        floatContainer.classList.add('float-container');
        floatCenteredContainer.classList.add('float-centered-container');
        notificationList.classList.add('float-container-list');
        notificationList.classList.add(meli.siteId);
        floatContainer.setAttribute('id', 'float-container');
        notificationList.setAttribute('id', 'float-container-list');

        if (notificationsBell) {
            var notificationsBellStyles = notificationsBell.getBoundingClientRect();
            notificationList.style.top = (notificationsBellStyles.top + notificationsBellStyles.height) + 'px';
            notificationList.style.right = (localWindow.innerWidth - (notificationsBellStyles.left + notificationsBellStyles.width * .5)) + 'px';
        }

        floatContainer.appendChild(floatCenteredContainer);
        floatCenteredContainer.appendChild(notificationList);

        doc.body.appendChild(floatContainer);
    };

    FloatNotifications.prototype.showFloatNotifications = function () {
        var self = this;
        this.getNotifications(function(response) {
            if (response.notify) {
                Array.prototype.forEach.call(response.data, function(elem) {
                    self.loadNotifications(self.decodeHTML(elem.html));
                });
                self.bindEvents();
                meli.notificationsAnimations.setNotificationsElements();
                meli.notificationsAnimations.animateNotifications(50, 2000, response);
            }
        });
    };

    FloatNotifications.prototype.getNotifications = function(callback) {
        var uri = this.settings.url;
        var self = this;
        var defaultOptions = {
            success:function(response) {
                var json = response[1];
                //Reload if versions differ
                if (json.version != self.version) {
                    self.reload(json.version);
                } else {
                    callback(json);
                }
            },
            error:function(response) {
                if (response[0] === 403) {
                    //TODO ver que hacer
                }
            }
        };

        this.jsonp(uri,defaultOptions);
    };

    FloatNotifications.prototype.reload = function(version) {
        var self = this;
        this.reloadCss(version);
        var iframe1 = doc.createElement('iframe');
        iframe1.style.display = 'none';
        iframe1.src = self.settings.url + '/reload?v=' + version;
        doc.body.appendChild(iframe1);

        (function(d,s,id) {
            var js,fjs=d.getElementsByTagName(s)[0];
            if(!d.getElementById(id)){
                js=d.createElement(s);
                js.id=id;
                js.src=self.settings.url + '/js/float.min.js?v=' + version;
                fjs.parentNode.insertBefore(js,fjs);
            }
        } (doc,'script','notifications-float-js-reload'));
    };

    FloatNotifications.prototype.reloadCss =function(version) {
        var link = doc.getElementById('float_notifications_css');
        link.setAttribute('href',link.href+'?v='+version);
    };

    FloatNotifications.prototype.loadNotifications = function(html) {
        var notificationContainer = doc.getElementById('float-container');
        var list = notificationContainer.querySelector('.float-container-list');
        list.insertAdjacentHTML('beforeend', html);
    };

    FloatNotifications.prototype.decodeHTML = function(str) {
        var element = doc.createElement('div');

        if(str && typeof str === 'string') {
            // strip script/html tags
            str = str.replace(/<script[^>]*>.*<\/script>/gmi, '');
            str = str.replace(/<\/?\w(?:[^"'>]|"[^"]*"|'[^']*')*>/gmi, '');
            element.innerHTML = str;
            str = element.textContent;
            element.textContent = '';
        }
        return str;
    };

    FloatNotifications.prototype.jsonp = function(url, settings) {
        /**
         * JSONP handler
         *
         * @method
         * @param {String} url
         * @param {Object} [settings] Optional opts.
         * @param {String} [settings.prefix] Callback prefix. Default: `__jsonp`
         * @param {String} [settings.param] QS parameter. Default: `callback`
         * @param {String|Function} [settings.name] The name of the callback function that
         *   receives the result. Default: `opts.prefix${increment}`
         * @param {Number} [settings.timeout] How long after the request until a timeout
         *   error will occur. Default: 15000
         *
         * @returns {Function} Returns a cancel function
         *
         * @example
         * var cancel = jsonp('http://suggestgz.mlapps.com/sites/MLA/autosuggest?q=smartphone&v=1', {timeout: 5000});
         * if (something) {
         *   cancel();
         * }
         */

        var id = void 0,
            script = void 0,
            timer = void 0,
            cleanup = void 0,
            cancel = void 0,
            param = 'callback',
            prefix = '__jsonp';

        var opts = {
            timeout: settings.timeout || 15000,
            success: settings.success || noop,
            error:   settings.error   || noop
        };

        // Generate an unique id for the request.
        jsonpCount++;
        id = opts.name ? typeof opts.name === 'function' ? opts.name(prefix, jsonpCount) : opts.name : prefix + jsonpCount++;

        cleanup = function cleanup() {
            // Remove the script tag.
            if (script && script.parentNode) {
                script.parentNode.removeChild(script);
            }

            // Don't delete the jsonp handler from win to not generate an error
            // when script will be loaded after cleaning
            win[id] = noop;

            if (timer) {
                clearTimeout(timer);
            }
        };

        if (opts.timeout) {
            timer = setTimeout(function () {
                cleanup();
                opts.error(new Error('Script loading timeout'));
            }, opts.timeout);
        }

        win[id] = function (data) {
            cleanup();
            opts.success(data);
        };

        // Add querystring component
        url += (~url.indexOf('?') ? '&' : '?') + param + '=' + encodeURIComponent(id);
        url = url.replace('?&', '?');

        // Create script element
        script = doc.createElement('script');
        script.async = true;
        script.src = url;
        script.onerror = function (e) {
            cleanup();
            opts.error(new Error(e.message || 'Script Error'));
        };
        doc.head.appendChild(script);

        cancel = function cancel() {
            if (win[id]) {
                cleanup();
            }
        };

        return cancel;
    };

    function FloatNotifications() {

        this.version = "bdaf3b07ec7118cafd20794b3a30ba0612b208c8";
        this.settings = {
            url: '//www.' + meli.domain + '/notifications/float',
            debug:false
        };
    }

    // Expose
    exports.floatNotifications = new FloatNotifications();

}(localWindow, localWindow.document, localWindow.Meli.prototype, localWindow.meli));

if (localWindow.floatAsyncInit) {
    localWindow.floatAsyncInit();
}
